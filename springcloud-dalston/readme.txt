简介
	Spring Cloud是一个基于Spring Boot实现的云应用开发工具，
		它为基于JVM的云应用开发中涉及的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。
	Spring Cloud包含了多个子项目（针对分布式系统中涉及的多个不同开源产品），
		比如：Spring Cloud Config、Spring Cloud Netflix、Spring Cloud0 CloudFoundry、Spring Cloud AWS、Spring Cloud Security、Spring Cloud Commons、Spring Cloud Zookeeper、Spring Cloud CLI等项目。

微服务架构
	微服务架构就是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每个服务都能独立部署、独立维护、独立扩展，服务与服务间通过诸如RESTful API的方式互相调用。

服务治理
	Spring Cloud为服务治理做了一层抽象接口，所以在Spring Cloud应用中可以支持多种不同的服务治理框架，比如：Netflix Eureka、Consul、Zookeeper。
	在Spring Cloud服务治理抽象层的作用下，我们可以无缝地切换服务治理实现，并且不影响任何其他的服务注册、服务发现、服务调用等逻辑。
	程序不需要做任何改变，只需要引入不同的服务治理依赖，并配置相关的配置属性就能轻松的将微服务纳入Spring Cloud的各个服务治理框架中。
    Spring Cloud Eureka
        Spring Cloud Eureka是Spring Cloud Netflix项目下的服务治理模块。
        而Spring Cloud Netflix项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，
        它为Spring Boot应用提供了自配置的Netflix OSS整合。通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。
        它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路由（Zuul），客户端负载均衡（Ribbon）等。
        Eureka Server的首页看到红色字体提示时，则说明Eureka已经进入了保护模式；
            一般出现此模式时，服务返回错误，即真实服务已经Down掉，但在注册中心界面服务一直存在，且显示为UP状态
            产生原因：
                Eureka Server在运行期间，会统计心跳失败的比例在15分钟之内是否
                低于85%，如果出现低于的情况（在单机调试的时候很容易满足，实际在
                生产环境上通常是由于网络不稳定导致），
                Eureka Server会将当前的实例注册信息保护起来，同时提
                示这个警告。保护模式主要用于一组客户端和Eureka Server之间存在网络分
                区场景下的保护。一旦进入保护模式，Eureka Server将会尝试保护其服务注
                册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务）。
    Spring Cloud Consul
        Spring Cloud Consul项目是针对Consul的服务治理实现。
        Consul是一个分布式高可用的系统，它包含多个组件，但是作为一个整体，在微服务架构中为我们的基础设施提供服务发现和服务配置的工具。
        它包含了下面几个特性：
            服务发现
            健康检查
            Key/Value存储
            多数据中心
        Consul自身提供了服务端，所以我们不需要像之前实现Eureka的时候创建服务注册中心，直接通过下载consul的服务端程序就可以使用。

LoadBalancerClient
    在Spring Cloud Commons中提供了大量的与服务治理相关的抽象接口，包括DiscoveryClient、LoadBalancerClient等;
    Spring Cloud做这一层抽象，很好的解耦了服务治理体系，使得我们可以轻易的替换不同的服务治理设施。
    LoadBalancerClient是一个负载均衡客户端的抽象定义

Spring Cloud Ribbon -- 客户端负载均衡工具包
    Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。它是一个基于HTTP和TCP的客户端负载均衡器。
    它可以通过在客户端中配置ribbonServerList来设置服务端列表去轮询访问以达到均衡负载的作用。
    当Ribbon与Eureka联合使用时，ribbonServerList会被DiscoveryEnabledNIWSServerList重写，扩展成从Eureka注册中心中获取服务实例列表。
    同时它也会用NIWSDiscoveryPing来取代IPing，它将职责委托给Eureka来确定服务端是否已经启动。
    而当Ribbon与Consul联合使用时，ribbonServerList会被ConsulServerList来扩展成从Consul获取服务实例列表。同时由ConsulPing来作为IPing接口的实现。
    我们在使用Spring Cloud Ribbon的时候，不论是与Eureka还是Consul结合，都会在引入Spring Cloud Eureka或Spring Cloud Consul依赖的时候通过自动化配置来加载上述所说的配置内容，
    所以我们可以快速在Spring Cloud中实现服务间调用的负载均衡。

Spring Cloud Feign -- 声明式服务调用客户端
    只需要通过创建接口并用注解来配置它既可完成对Web服务接口的绑定。
    它具备可插拔的注解支持，包括Feign注解、JAX-RS注解。
    它也支持可插拔的编码器和解码器。
    Spring Cloud Feign还扩展了对Spring MVC注解的支持，同时还整合了Ribbon和Eureka来提供均衡负载的HTTP客户端实现。

Spring Cloud Hystrix
    Hystrix目标在于通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力;
    具备了服务降级、服务熔断、线程隔离、请求缓存、请求合并以及服务监控等强大功能。
    依赖隔离：
        “舱壁模式”对于熟悉Docker的读者一定不陌生，Docker通过“舱壁模式”实现进程的隔离，使得容器与容器之间不会互相影响。
        而Hystrix则使用该模式实现线程池的隔离，它会为每一个Hystrix命令创建一个独立的线程池，
        这样就算某个在Hystrix命令包装下的依赖服务出现延迟过高的情况，也只是对该依赖服务的调用产生影响，而不会拖慢其他的服务。
        优势：
            1、应用自身得到完全的保护，不会受不可控的依赖服务影响。即便给依赖服务分配的线程池被填满，也不会影响应用自身的额其余部分。
            2、可以有效的降低接入新服务的风险。如果新服务接入后运行不稳定或存在问题，完全不会影响到应用其他的请求。
            3、当依赖的服务从失效恢复正常后，它的线程池会被清理并且能够马上恢复健康的服务，相比之下容器级别的清理恢复速度要慢得多。
            4、当依赖的服务出现配置错误的时候，线程池会快速的反应出此问题（通过失败次数、延迟、超时、拒绝等指标的增加情况）。同时，我们可以在不影响应用功能的情况下通过实时的动态属性刷新来处理它。
            5、当依赖的服务因实现机制调整等原因造成其性能出现很大变化的时候，此时线程池的监控指标信息会反映出这样的变化。同时，我们也可以通过实时动态刷新自身应用对依赖服务的阈值进行调整以适应依赖方的改变。
            6、每个专有线程池都提供了内置的并发实现，可以利用它为同步的依赖服务构建异步的访问。
        Hystrix中除了使用线程池之外，还可以使用信号量来控制单个依赖服务的并发度，信号量的开销要远比线程池的开销小得多，但是它不能设置超时和实现异步访问。所以，只有在依赖服务是足够可靠的情况下才使用信号量。
        在HystrixCommand和HystrixObservableCommand中2处支持信号量的使用：
            命令执行：如果隔离策略参数execution.isolation.strategy设置为SEMAPHORE，Hystrix会使用信号量替代线程池来控制依赖服务的并发控制。
            降级逻辑：当Hystrix尝试降级逻辑时候，它会在调用线程中使用信号量。
        使用：
            @HystrixCommand来将某个函数包装成了Hystrix命令，这里除了定义服务降级之外，Hystrix框架就会自动的为这个函数实现调用的隔离。
            所以，依赖隔离、服务降级在使用时候都是一体化实现的，这样利用Hystrix来实现服务容错保护在编程模型上就非常方便的，并且考虑更为全面。
    断路器：
        “断路器”本身是一种开关装置，用于在电路上保护线路过载，当线路中有电器发生短路时，“断路器”能够及时的切断故障电路，防止发生过载、发热、甚至起火等严重后果。
        在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），直接切断原来的主逻辑调用。
        在服务消费端的服务降级逻辑因为hystrix命令调用依赖服务超时，触发了降级逻辑，但是即使这样，受限于Hystrix超时时间的问题，我们的调用依然很有可能产生堆积；此时断路器就会发挥作用。
        断路器的三个重要参数：快照时间窗、请求总数下限、错误百分比下限：这个参数的作用分别是：
            1、快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。
            2、请求总数下限：在快照时间窗内，必须满足请求总数下限才有资格根据熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用此时不足20次，即时所有的请求都超时或其他原因失败，断路器都不会打开。
            3、错误百分比下限：当请求总数在快照时间窗内超过了下限，比如发生了30次调用，如果在这30次调用中，有16次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%下限情况下，这时候就会将断路器打开。
        断路器的效果：
            断路器未打开之前，每个请求都会在当hystrix超时之后返回fallback，每个请求的时间延迟就是近似hystrix的超时时间；
            如果hystrix的超时时间设置为5s，那么每个请求就都要延迟5s才会返回；
            当熔断器在10s内发现请求总数超过20，并且错误百分比超过50%，这时熔断器会打开；
            打开之后，再有请求调用的时候，将不会调用主逻辑，而直接调用降级逻辑，此时不需要等待超时返回fallback，减少延迟效果。
            在断路器打开之后，处理逻辑并没有结束，我们的降级逻辑已经变成了主逻辑，那么原来的主逻辑要如何恢复呢？
            对于这一问题，hystrix也为我们实现了自动恢复功能。
            当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，当休眠时间窗到期，
            断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，主逻辑恢复，
            如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。
    控制面板：
        Hystrix Dashboard共支持三种不同的监控方式，依次为：
            1、默认的集群监控：通过URLhttp://turbine-hostname:port/turbine.stream开启，实现对默认集群的监控。
            2、指定的集群监控：通过URLhttp://turbine-hostname:port/turbine.stream?cluster=[clusterName]开启，实现对clusterName集群的监控。
            3、单体应用的监控：通过URLhttp://hystrix-app:port/hystrix.stream开启，实现对具体某个服务实例的监控。
        但实例服务监控：
            参数说明：
                http://待检测服务IP:port/hystrix.stream
                Delay：该参数用来控制服务器上轮询监控信息的延迟时间，默认为2000毫秒；
                Title：标题，默认会使用具体监控实例的URL，我们可以通过配置该信息来展示更合适的标题。
            监控页面各元素的含义：
                我们可以在监控信息的左上部分找到两个重要的图形信息：一个实心圆和一条曲线。
                实心圆：共有两种含义。它通过颜色的变化代表了实例的健康程度；
                    它的健康度从绿色、黄色、橙色、红色递减；
                    它的大小也会根据实例的请求流量发生变化，流量越大该实心圆就越大。
                    所以通过该实心圆的展示，我们就可以在大量的实例中快速的发现故障实例和高压力实例。
                曲线：用来记录2分钟内流量的相对变化，我们可以通过它来观察到流量的上升和下降趋势。

Spring Cloud Zuul
    服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。
    Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，
    使得服务集群主体能够具备更高的可复用性和可测试性。

Spring Cloud Stream
    简介：
        Spring Cloud Stream是一个用来为微服务应用构建消息驱动能力的框架。
        它可以基于Spring Boot来创建独立的、可用于生产的Spring应用程序。
        它通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动的微服务应用。
        Spring Cloud Stream为一些供应商的消息中间件产品提供了个性化的自动化配置实现，并且引入了发布-订阅、消费组以及消息分区这三个核心概念。
        简单的说，Spring Cloud Stream本质上就是整合了Spring Boot和Spring Integration，实现了一套轻量级的消息驱动的微服务框架。
        通过使用Spring Cloud Stream，可以有效地简化开发人员对消息中间件的使用复杂度，让系统开发人员可以有更多的精力关注于核心业务逻辑的处理。
        由于Spring Cloud Stream基于Spring Boot实现，所以它秉承了Spring Boot的优点，实现了自动化配置的功能帮忙我们可以快速的上手使用，
        但是目前为止Spring Cloud Stream只支持下面两个著名的消息中间件的自动化配置：RabbitMQ、Kafka。
    工作原理：
        Spring Cloud Stream构建的应用程序与消息中间件之间是通过绑定器Binder相关联的，
        绑定器对于应用程序而言起到了隔离作用，它使得不同消息中间件的实现细节对应用程序来说是透明的。
        所以对于每一个Spring Cloud Stream的应用程序来说，它不需要知晓消息中间件的通信细节，
        它只需要知道Binder对应用程序提供的概念去实现即可，而这个概念就是消息通道：Channel;
        绑定器则是作为这些通道和消息中间件之间的桥梁进行通信。
    绑定器(Binder):
        Binder绑定器是Spring Cloud Stream中一个非常重要的概念；
        通过定义绑定器作为中间层，完美地实现了应用程序与消息中间件细节之间的隔离。
        通过向应用程序暴露统一的Channel通道，使得应用程序不需要再考虑各种不同的消息中间件实现。
        当我们需要升级消息中间件，或是更换其他消息中间件产品时，我们要做的就是更换它们对应的Binder绑定器而不需要修改任何Spring Boot的应用逻辑。
    发布-订阅模式:
        在Spring Cloud Stream中的消息通信方式遵循了发布-订阅模式，当一条消息被投递到消息中间件之后，
        它会通过共享的Topic主题进行广播，消息消费者在订阅的主题中收到它并触发自身的业务逻辑处理。
        这里所提到的Topic主题是Spring Cloud Stream中的一个抽象概念，用来代表发布共享消息给消费者的地方。
        在不同的消息中间件中，Topic可能对应着不同的概念，比如：在RabbitMQ中的它对应了Exchange、而在Kakfa中则对应了Kafka中的Topic。
        当该Topic中有消息发布进来后，连接到该Topic上的所有订阅者可以收到该消息并根据自身的需求进行消费操作。
        相对于点对点队列实现的消息通信来说，Spring Cloud Stream采用的发布-订阅模式可以有效的降低消息生产者与消费者之间的耦合，
        当我们需要对同一类消息增加一种处理方式时，只需要增加一个应用程序并将输入通道绑定到既有的Topic中就可以实现功能的扩展，而不需要改变原来已经实现的任何内容。
    消费组:
        虽然Spring Cloud Stream通过发布-订阅模式将消息生产者与消费者做了很好的解耦，基于相同主题的消费者可以轻松的进行扩展，
        但是这些扩展都是针对不同的应用实例而言的，在现实的微服务架构中，我们每一个微服务应用为了实现高可用和负载均衡，实际上都会部署多个实例。
        很多情况下，消息生产者发送消息给某个具体微服务时，只希望被消费一次，
        当启动同一应用的不同实例时，出现一条消息被重复消费的情况；为了解决这个问题，在Spring Cloud Stream中提供了消费组的概念。
        如果在同一个主题上的应用需要启动多个实例的时候，我们可以通过spring.cloud.stream.bindings.input.group属性为应用指定一个组名，
        这样这个应用的多个实例在接收到消息的时候，只会有一个成员真正的收到消息并进行处理。
    消息分区:
        通过引入消费组的概念，我们已经能够在多实例的情况下，保障每个消息只被组内一个实例进行消费。
        通过上面对消费组参数设置后的实验，我们可以观察到，消费组并无法控制消息具体被哪个实例消费。
        也就是说，对于同一条消息，它多次到达之后可能是由不同的实例进行消费的。
        但是对于一些业务场景，就需要对于一些具有相同特征的消息每次都可以被同一个消费实例处理，
        比如：一些用于监控服务，为了统计某段时间内消息生产者发送的报告内容，监控服务需要在自身内容聚合这些数据，
        那么消息生产者可以为消息增加一个固有的特征ID来进行分区，使得拥有这些ID的消息每次都能被发送到一个特定的实例上实现累计统计的效果，
        否则这些数据就会分散到各个不同的节点导致监控结果不一致的情况。
        而分区概念的引入就是为了解决这样的问题：当生产者将消息数据发送给多个消费者实例时，保证拥有共同特征的消息数据始终是由同一个消费者实例接收和处理。
        Spring Cloud Stream为分区提供了通用的抽象实现，用来在消息中间件的上层实现分区处理，所以它对于消息中间件自身是否实现了消息分区并不关心，
        这使得Spring Cloud Stream为不具备分区功能的消息中间件也增加了分区功能扩展。

Spring Cloud Sleuth
    分布式系统中的服务跟踪在理论上并不复杂，它主要包括下面两个关键点：
        1、为了实现请求跟踪，当请求发送到分布式系统的入口端点时，只需要服务跟踪框架为该请求创建一个唯一的跟踪标识，
        同时在分布式系统内部流转的时候，框架始终保持传递该唯一标识，直到返回给请求方为止，这个唯一标识就是Trace ID。
        通过Trace ID的记录，我们就能将所有请求过程日志关联起来。
        2、为了统计各处理单元的时间延迟，当请求达到各个服务组件时，或是处理逻辑到达某个状态时，
        也通过一个唯一标识来标记它的开始、具体过程以及结束，该标识就是Span ID，
        对于每个Span来说，它必须有开始和结束两个节点，通过记录开始Span和结束Span的时间戳，就能统计出该Span的时间延迟，
        除了时间戳记录之外，它还可以包含一些其他元数据，比如：事件名称、请求信息等。
    sleuth会为在该请求的Header中增加实现跟踪需要的重要信息，主要有下面这几个（更多关于头信息的定义我们可以通过查看org.springframework.cloud.sleuth.Span的源码获取）：
        1、X-B3-TraceId：一条请求链路（Trace）的唯一标识，必须值
        2、X-B3-SpanId：一个工作单元（Span）的唯一标识，必须值
        3、X-B3-ParentSpanId:：标识当前工作单元所属的上一个工作单元，Root Span（请求链路的第一个工作单元）的该值为空
        4、X-B3-Sampled：是否被抽样输出的标志，1表示需要被输出，0表示不需要被输出
        5、X-Span-Name：工作单元的名称
    整合logstash，集中、存储、搜索sleuth的跟踪信息：
        引入基于日志的分析系统，比如：ELK平台，它可以轻松的帮助我们来收集和存储这些跟踪日志，
        同时在需要的时候我们也可以根据Trace ID来轻松地搜索出对应请求链路相关的明细日志。
        ELK平台主要有由ElasticSearch、Logstash和Kiabana三个开源免费工具组成：
            Elasticsearch是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。
            Logstash是一个完全开源的工具，他可以对你的日志进行收集、过滤，并将其存储供以后使用。
            Kibana 也是一个开源和免费的工具，它Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志。
    整合zipkin:
        简介：
            Zipkin是Twitter的一个开源项目，它基于Google Dapper实现。
            我们可以使用它来收集各个服务器上请求链路的跟踪数据，并通过它提供的REST API接口来辅助我们查询跟踪数据以实现对分布式系统的监控程序，
            从而及时地发现系统中出现的延迟升高问题并找出系统性能瓶颈的根源。
            除了面向开发的API接口之外，它也提供了方便的UI组件来帮助我们直观的搜索跟踪信息和分析请求链路明细，
            比如：可以查询某段时间内各用户请求的处理时间等。
        核心组件：
            1、Collector：收集器组件，它主要用于处理从外部系统发送过来的跟踪信息，将这些信息转换为Zipkin内部处理的Span格式，以支持后续的存储、分析、展示等功能。
            2、Storage：存储组件，它主要对处理收集器接收到的跟踪信息，默认会将这些信息存储在内存中，我们也可以修改此存储策略，通过使用其他存储组件将跟踪信息存储到数据库中。
            3、RESTful API：API组件，它主要用来提供外部访问接口。比如给客户端展示跟踪信息，或是外接系统访问以实现监控等。
            4、Web UI：UI组件，基于API组件实现的上层应用。通过UI组件用户可以方便而有直观地查询和分析跟踪信息。






































































